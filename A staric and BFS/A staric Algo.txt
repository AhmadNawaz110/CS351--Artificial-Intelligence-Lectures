<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>A* Algorithm in AI - Detailed Presentation</title>
    <link href="https://fonts.googleapis.com/css2?family=Roboto:wght@300;400;500;700&display=swap" rel="stylesheet">
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.0.0-beta3/css/all.min.css">
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }
        body {
            font-family: 'Roboto', sans-serif;
            background: linear-gradient(135deg, #1a2a6c, #b21f1f, #fdbb2d);
            color: #333;
            display: flex;
            justify-content: center;
            align-items: center;
            min-height: 100vh;
            padding: 20px;
        }
        .presentation {
            width: 100%;
            max-width: 1200px;
            background: white;
            border-radius: 15px;
            box-shadow: 0 20px 60px rgba(0,0,0,0.3);
            overflow: hidden;
        }
        .slide {
            display: none;
            padding: 40px;
            min-height: 650px;
            position: relative;
        }
        .slide.active {
            display: block;
            animation: fadeIn 0.5s ease-in-out;
        }
        @keyframes fadeIn {
            from { opacity: 0; transform: translateY(20px); }
            to { opacity: 1; transform: translateY(0); }
        }
        .slide h1 {
            font-size: 2.8rem;
            margin-bottom: 20px;
            color: #1a2a6c;
            text-align: center;
        }
        .slide h2 {
            font-size: 2.2rem;
            margin-bottom: 20px;
            color: #b21f1f;
            border-bottom: 3px solid #fdbb2d;
            padding-bottom: 10px;
        }
        .slide h3 {
            font-size: 1.6rem;
            margin: 15px 0 10px;
            color: #1a2a6c;
        }
        .slide p, .slide li {
            font-size: 1.2rem;
            line-height: 1.6;
            margin-bottom: 15px;
        }
        .slide ul {
            margin-left: 30px;
        }
        .slide li {
            margin-bottom: 10px;
        }
        .formula {
            background: #f8f9fa;
            padding: 15px;
            border-radius: 10px;
            border-left: 5px solid #fdbb2d;
            font-size: 1.5rem;
            text-align: center;
            margin: 20px 0;
            font-family: 'Courier New', monospace;
        }
        .visual-container {
            display: flex;
            justify-content: center;
            margin: 30px 0;
        }
        .navigation {
            position: absolute;
            bottom: 20px;
            right: 20px;
            display: flex;
            gap: 10px;
        }
        .nav-btn {
            background: #1a2a6c;
            color: white;
            border: none;
            padding: 10px 20px;
            border-radius: 25px;
            cursor: pointer;
            font-size: 1rem;
            transition: all 0.3s;
        }
        .nav-btn:hover {
            background: #fdbb2d;
            transform: translateY(-3px);
        }
        .grid-container {
            display: flex;
            justify-content: center;
            margin: 20px 0;
        }
        .grid-cell {
            width: 40px;
            height: 40px;
            border: 1px solid #ccc;
            display: flex;
            align-items: center;
            justify-content: center;
            font-weight: bold;
            font-size: 0.9rem;
        }
        .start { background-color: #4CAF50; }
        .goal { background-color: #F44336; }
        .obstacle { background-color: #333; color: white; }
        .path { background-color: #2196F3; color: white; }
        .visited { background-color: #FFEB3B; }
        .current { background-color: #9C27B0; color: white; }
        .comparison {
            display: flex;
            justify-content: space-around;
            margin: 20px 0;
        }
        .comparison-item {
            text-align: center;
            padding: 15px;
            border-radius: 10px;
            background: #f1f1f1;
            width: 30%;
        }
        .comparison-item h4 {
            margin-bottom: 10px;
            color: #1a2a6c;
        }
        .highlight {
            background: #FFF9C4;
            padding: 3px 6px;
            border-radius: 4px;
        }
        .app-grid {
            display: grid;
            grid-template-columns: repeat(3, 1fr);
            gap: 20px;
            margin: 20px 0;
        }
        .app-item {
            background: #f1f1f1;
            padding: 15px;
            border-radius: 10px;
            text-align: center;
            transition: transform 0.3s;
        }
        .app-item:hover {
            transform: translateY(-5px);
            box-shadow: 0 5px 15px rgba(0,0,0,0.1);
        }
        .app-icon {
            font-size: 2.5rem;
            margin-bottom: 10px;
        }
        .code-block {
            background: #282c34;
            color: #abb2bf;
            padding: 20px;
            border-radius: 10px;
            font-family: 'Courier New', monospace;
            overflow-x: auto;
            margin: 20px 0;
            font-size: 0.9rem;
            line-height: 1.5;
        }
        .code-comment {
            color: #5c6370;
            font-style: italic;
        }
        .code-keyword {
            color: #c678dd;
        }
        .code-string {
            color: #98c379;
        }
        .code-function {
            color: #61afef;
        }
        .code-number {
            color: #d19a66;
        }
        .step-container {
            display: flex;
            margin: 20px 0;
        }
        .step-number {
            background: #1a2a6c;
            color: white;
            width: 40px;
            height: 40px;
            border-radius: 50%;
            display: flex;
            align-items: center;
            justify-content: center;
            font-weight: bold;
            margin-right: 15px;
            flex-shrink: 0;
        }
        .step-content {
            flex-grow: 1;
        }
        .tab-container {
            margin: 20px 0;
        }
        .tab-buttons {
            display: flex;
            border-bottom: 2px solid #e0e0e0;
        }
        .tab-button {
            background: none;
            border: none;
            padding: 10px 20px;
            font-size: 1rem;
            cursor: pointer;
            position: relative;
            transition: all 0.3s;
        }
        .tab-button.active {
            color: #1a2a6c;
            font-weight: bold;
        }
        .tab-button.active::after {
            content: '';
            position: absolute;
            bottom: -2px;
            left: 0;
            width: 100%;
            height: 2px;
            background: #1a2a6c;
        }
        .tab-content {
            display: none;
            padding: 20px;
            background: #f9f9f9;
            border-radius: 0 0 10px 10px;
        }
        .tab-content.active {
            display: block;
        }
        .integration-diagram {
            display: flex;
            justify-content: space-between;
            margin: 30px 0;
        }
        .integration-step {
            width: 30%;
            background: #f1f1f1;
            padding: 20px;
            border-radius: 10px;
            text-align: center;
            position: relative;
        }
        .integration-step:not(:last-child)::after {
            content: '\f054';
            font-family: 'Font Awesome 6 Free';
            font-weight: 900;
            position: absolute;
            right: -20px;
            top: 50%;
            transform: translateY(-50%);
            color: #1a2a6c;
            font-size: 1.5rem;
        }
    </style>
</head>
<body>
    <div class="presentation">
        <!-- Slide 1: Title Slide -->
        <div class="slide active">
            <h1>A* Search Algorithm in Artificial Intelligence</h1>
            <div class="visual-container">
                <svg width="500" height="300" viewBox="0 0 500 300">
                    <!-- Grid background -->
                    <defs>
                        <pattern id="smallGrid" width="50" height="50" patternUnits="userSpaceOnUse">
                            <path d="M 50 0 L 0 0 0 50" fill="none" stroke="#e0e0e0" stroke-width="1"/>
                        </pattern>
                    </defs>
                    <rect width="100%" height="100%" fill="url(#smallGrid)" />
                    
                    <!-- Start point -->
                    <circle cx="75" cy="75" r="20" fill="#4CAF50" />
                    <text x="75" y="80" text-anchor="middle" fill="white" font-weight="bold">S</text>
                    
                    <!-- Goal point -->
                    <circle cx="425" cy="225" r="20" fill="#F44336" />
                    <text x="425" y="230" text-anchor="middle" fill="white" font-weight="bold">G</text>
                    
                    <!-- Obstacles -->
                    <rect x="150" y="100" width="50" height="150" fill="#333" />
                    <rect x="250" y="50" width="50" height="100" fill="#333" />
                    <rect x="350" y="150" width="50" height="100" fill="#333" />
                    
                    <!-- Optimal path -->
                    <path d="M75,75 L125,75 L125,175 L175,175 L225,175 L225,225 L275,225 L325,225 L375,225 L425,225" 
                          stroke="#2196F3" stroke-width="4" fill="none" stroke-dasharray="8,4" />
                    
                    <!-- Robot icon -->
                    <g transform="translate(75,75)">
                        <circle cx="0" cy="0" r="25" fill="#2196F3" opacity="0.8" />
                        <rect x="-15" y="-15" width="30" height="30" rx="5" fill="#1976D2" />
                        <circle cx="-8" cy="-8" r="3" fill="white" />
                        <circle cx="8" cy="-8" r="3" fill="white" />
                        <path d="M-10,5 Q0,15 10,5" stroke="white" stroke-width="2" fill="none" />
                    </g>
                    
                    <!-- Title -->
                    <text x="250" y="40" text-anchor="middle" font-size="24" font-weight="bold" fill="#1a2a6c">Optimal Pathfinding</text>
                </svg>
            </div>
            <p style="text-align: center; font-size: 1.4rem; margin-top: 30px;">Combining Optimality and Efficiency in Pathfinding</p>
            <div class="navigation">
                <button class="nav-btn" onclick="changeSlide(1)">Next ‚Üí</button>
            </div>
        </div>

        <!-- Slide 2: Introduction to A* -->
        <div class="slide">
            <h2>What is A*?</h2>
            <div class="comparison">
                <div class="comparison-item">
                    <h4>Dijkstra's Algorithm</h4>
                    <p>Guarantees shortest path</p>
                    <p>Explores in all directions</p>
                    <p style="color: #F44336;">Inefficient for large graphs</p>
                </div>
                <div class="comparison-item">
                    <h4>Greedy Best-First</h4>
                    <p>Uses heuristics for speed</p>
                    <p>Fast but not optimal</p>
                    <p style="color: #F44336;">May miss shortest path</p>
                </div>
                <div class="comparison-item">
                    <h4>A* Algorithm</h4>
                    <p><span class="highlight">Optimal</span> + <span class="highlight">Efficient</span></p>
                    <p>Combines both approaches</p>
                    <p style="color: #4CAF50;">Best of both worlds</p>
                </div>
            </div>
            
            <div class="visual-container">
                <svg width="600" height="200" viewBox="0 0 600 200">
                    <!-- Dijkstra visualization -->
                    <g transform="translate(50, 50)">
                        <circle cx="0" cy="0" r="20" fill="#4CAF50" />
                        <text x="0" y="5" text-anchor="middle" fill="white" font-weight="bold">S</text>
                        
                        <circle cx="100" cy="0" r="20" fill="#FFEB3B" />
                        <circle cx="0" cy="100" r="20" fill="#FFEB3B" />
                        <circle cx="100" cy="100" r="20" fill="#FFEB3B" />
                        <circle cx="200" cy="0" r="20" fill="#FFEB3B" />
                        
                        <circle cx="300" cy="50" r="20" fill="#F44336" />
                        <text x="300" y="55" text-anchor="middle" fill="white" font-weight="bold">G</text>
                        
                        <line x1="20" y1="0" x2="80" y2="0" stroke="#333" stroke-width="2" />
                        <line x1="0" y1="20" x2="0" y2="80" stroke="#333" stroke-width="2" />
                        <line x1="100" y1="20" x2="100" y2="80" stroke="#333" stroke-width="2" />
                        <line x1="20" y1="100" x2="80" y2="100" stroke="#333" stroke-width="2" />
                        <line x1="120" y1="0" x2="180" y2="0" stroke="#333" stroke-width="2" />
                        <line x1="220" y1="0" x2="280" y2="50" stroke="#333" stroke-width="2" />
                        <line x1="100" y1="120" x2="280" y2="70" stroke="#333" stroke-width="2" />
                        
                        <text x="50" y="-20" text-anchor="middle" font-weight="bold">Dijkstra</text>
                    </g>
                    
                    <!-- A* visualization -->
                    <g transform="translate(350, 50)">
                        <circle cx="0" cy="0" r="20" fill="#4CAF50" />
                        <text x="0" y="5" text-anchor="middle" fill="white" font-weight="bold">S</text>
                        
                        <circle cx="100" cy="0" r="20" fill="#2196F3" />
                        <circle cx="0" cy="100" r="20" fill="#FFEB3B" />
                        <circle cx="100" cy="100" r="20" fill="#FFEB3B" />
                        <circle cx="200" cy="0" r="20" fill="#2196F3" />
                        
                        <circle cx="300" cy="50" r="20" fill="#F44336" />
                        <text x="300" y="55" text-anchor="middle" fill="white" font-weight="bold">G</text>
                        
                        <line x1="20" y1="0" x2="80" y2="0" stroke="#2196F3" stroke-width="3" />
                        <line x1="0" y1="20" x2="0" y2="80" stroke="#333" stroke-width="1" stroke-dasharray="3,2" />
                        <line x1="100" y1="20" x2="100" y2="80" stroke="#333" stroke-width="1" stroke-dasharray="3,2" />
                        <line x1="20" y1="100" x2="80" y2="100" stroke="#333" stroke-width="1" stroke-dasharray="3,2" />
                        <line x1="120" y1="0" x2="180" y2="0" stroke="#2196F3" stroke-width="3" />
                        <line x1="220" y1="0" x2="280" y2="50" stroke="#2196F3" stroke-width="3" />
                        <line x1="100" y1="120" x2="280" y2="70" stroke="#333" stroke-width="1" stroke-dasharray="3,2" />
                        
                        <text x="150" y="-20" text-anchor="middle" font-weight="bold">A*</text>
                    </g>
                </svg>
            </div>
            
            <ul>
                <li><strong>Informed search algorithm</strong> for pathfinding and graph traversal</li>
                <li><strong>Key innovation:</strong> Uses both actual cost and heuristic estimate</li>
                <li><strong>Applications:</strong> Robotics, gaming, network routing, AI planning</li>
            </ul>
            <div class="navigation">
                <button class="nav-btn" onclick="changeSlide(0)">‚Üê Prev</button>
                <button class="nav-btn" onclick="changeSlide(2)">Next ‚Üí</button>
            </div>
        </div>

        <!-- Slide 3: Key Components -->
        <div class="slide">
            <h2>The Cost Functions</h2>
            <div class="formula">
                f(n) = g(n) + h(n)
            </div>
            
            <div class="visual-container">
                <svg width="700" height="350" viewBox="0 0 700 350">
                    <!-- Main path -->
                    <path d="M100,250 L200,200 L300,150 L400,100 L500,150 L600,100" 
                          stroke="#2196F3" stroke-width="4" fill="none" />
                    
                    <!-- Start node -->
                    <circle cx="100" cy="250" r="25" fill="#4CAF50" />
                    <text x="100" y="255" text-anchor="middle" fill="white" font-weight="bold">S</text>
                    
                    <!-- Current node -->
                    <circle cx="400" cy="100" r="25" fill="#9C27B0" />
                    <text x="400" y="105" text-anchor="middle" fill="white" font-weight="bold">n</text>
                    
                    <!-- Goal node -->
                    <circle cx="600" cy="100" r="25" fill="#F44336" />
                    <text x="600" y="105" text-anchor="middle" fill="white" font-weight="bold">G</text>
                    
                    <!-- g(n) annotation -->
                    <path d="M100,250 L400,100" stroke="#4CAF50" stroke-width="3" stroke-dasharray="5,3" />
                    <text x="250" y="160" text-anchor="middle" fill="#4CAF50" font-weight="bold" font-size="18">g(n)</text>
                    <text x="250" y="180" text-anchor="middle" fill="#4CAF50">Actual cost from S to n</text>
                    
                    <!-- h(n) annotation -->
                    <path d="M400,100 L600,100" stroke="#FF9800" stroke-width="3" stroke-dasharray="5,3" />
                    <text x="500" y="90" text-anchor="middle" fill="#FF9800" font-weight="bold" font-size="18">h(n)</text>
                    <text x="500" y="70" text-anchor="middle" fill="#FF9800">Heuristic estimate from n to G</text>
                    
                    <!-- f(n) annotation -->
                    <path d="M100,250 L600,100" stroke="#E91E63" stroke-width="2" stroke-dasharray="8,4" />
                    <text x="350" y="280" text-anchor="middle" fill="#E91E63" font-weight="bold" font-size="18">f(n) = g(n) + h(n)</text>
                    <text x="350" y="300" text-anchor="middle" fill="#E91E63">Total estimated cost</text>
                    
                    <!-- Legend -->
                    <g transform="translate(50, 30)">
                        <rect width="600" height="40" fill="#f1f1f1" rx="5" />
                        <circle cx="30" cy="20" r="8" fill="#4CAF50" />
                        <text x="45" y="25" font-size="14">Start</text>
                        
                        <circle cx="150" cy="20" r="8" fill="#9C27B0" />
                        <text x="165" y="25" font-size="14">Current Node</text>
                        
                        <circle cx="280" cy="20" r="8" fill="#F44336" />
                        <text x="295" y="25" font-size="14">Goal</text>
                        
                        <line x1="400" y1="20" x2="430" y2="20" stroke="#2196F3" stroke-width="3" />
                        <text x="440" y="25" font-size="14">Optimal Path</text>
                    </g>
                </svg>
            </div>
            
            <div style="display: flex; justify-content: space-around; margin-top: 20px;">
                <div style="background: #E8F5E9; padding: 15px; border-radius: 10px; width: 30%;">
                    <h3 style="color: #2E7D32;">g(n)</h3>
                    <p>Actual cost from start node to current node n</p>
                    <p><strong>Example:</strong> Distance traveled so far</p>
                </div>
                <div style="background: #FFF3E0; padding: 15px; border-radius: 10px; width: 30%;">
                    <h3 style="color: #E65100;">h(n)</h3>
                    <p>Heuristic estimate from node n to goal</p>
                    <p><strong>Example:</strong> Straight-line distance</p>
                </div>
                <div style="background: #F3E5F5; padding: 15px; border-radius: 10px; width: 30%;">
                    <h3 style="color: #6A1B9A;">f(n)</h3>
                    <p>Total estimated cost = g(n) + h(n)</p>
                    <p><strong>A* priority:</strong> Lowest f(n) first</p>
                </div>
            </div>
            <div class="navigation">
                <button class="nav-btn" onclick="changeSlide(1)">‚Üê Prev</button>
                <button class="nav-btn" onclick="changeSlide(3)">Next ‚Üí</button>
            </div>
        </div>

        <!-- Slide 4: Heuristic Function -->
        <div class="slide">
            <h2>The Power of Heuristics</h2>
            <div class="visual-container">
                <svg width="600" height="400" viewBox="0 0 600 400">
                    <!-- Grid background -->
                    <defs>
                        <pattern id="grid" width="50" height="50" patternUnits="userSpaceOnUse">
                            <path d="M 50 0 L 0 0 0 50" fill="none" stroke="#e0e0e0" stroke-width="1"/>
                        </pattern>
                    </defs>
                    <rect width="100%" height="100%" fill="url(#grid)" />
                    
                    <!-- Start and Goal -->
                    <circle cx="75" cy="75" r="20" fill="#4CAF50" />
                    <text x="75" y="80" text-anchor="middle" fill="white" font-weight="bold">S</text>
                    
                    <circle cx="425" cy="325" r="20" fill="#F44336" />
                    <text x="425" y="330" text-anchor="middle" fill="white" font-weight="bold">G</text>
                    
                    <!-- Manhattan distance visualization -->
                    <path d="M75,75 L425,75 L425,325" stroke="#FF9800" stroke-width="3" fill="none" stroke-dasharray="8,4" />
                    <text x="250" y="65" text-anchor="middle" fill="#FF9800" font-weight="bold">Manhattan: |Œîx| + |Œîy|</text>
                    <text x="250" y="85" text-anchor="middle" fill="#FF9800">7 + 5 = 12 units</text>
                    
                    <!-- Euclidean distance visualization -->
                    <line x1="75" y1="75" x2="425" y2="325" stroke="#2196F3" stroke-width="3" />
                    <text x="250" y="210" text-anchor="middle" fill="#2196F3" font-weight="bold" transform="rotate(-35, 250, 210)">Euclidean: ‚àö(Œîx¬≤ + Œîy¬≤)</text>
                    <text x="250" y="230" text-anchor="middle" fill="#2196F3" transform="rotate(-35, 250, 230)">‚àö(49 + 25) ‚âà 8.6 units</text>
                    
                    <!-- Comparison boxes -->
                    <g transform="translate(50, 350)">
                        <rect width="200" height="40" fill="#FFF3E0" rx="5" />
                        <text x="100" y="25" text-anchor="middle" font-weight="bold">Manhattan Distance</text>
                    </g>
                    
                    <g transform="translate(350, 350)">
                        <rect width="200" height="40" fill="#E3F2FD" rx="5" />
                        <text x="100" y="25" text-anchor="middle" font-weight="bold">Euclidean Distance</text>
                    </g>
                </svg>
            </div>
            
            <div style="display: flex; justify-content: space-between; margin-top: 20px;">
                <div style="width: 48%;">
                    <h3>Admissible Heuristic</h3>
                    <ul>
                        <li>Never overestimates true cost</li>
                        <li>Ensures path optimality</li>
                        <li>Example: Manhattan distance for grid movement</li>
                    </ul>
                </div>
                <div style="width: 48%;">
                    <h3>Heuristic Impact</h3>
                    <ul>
                        <li>Better heuristics ‚Üí Fewer nodes explored</li>
                        <li>Manhattan: Good for grid-based games</li>
                        <li>Euclidean: Better for continuous space</li>
                    </ul>
                </div>
            </div>
            <div class="navigation">
                <button class="nav-btn" onclick="changeSlide(2)">‚Üê Prev</button>
                <button class="nav-btn" onclick="changeSlide(4)">Next ‚Üí</button>
            </div>
        </div>

        <!-- Slide 5: Algorithm Steps -->
        <div class="slide">
            <h2>A* Algorithm Steps</h2>
            <div class="visual-container">
                <svg width="700" height="400" viewBox="0 0 700 400">
                    <!-- Flowchart background -->
                    <rect width="100%" height="100%" fill="#f9f9f9" rx="10" />
                    
                    <!-- Start -->
                    <ellipse cx="350" cy="50" rx="80" ry="30" fill="#4CAF50" />
                    <text x="350" y="55" text-anchor="middle" fill="white" font-weight="bold">START</text>
                    
                    <!-- Initialize -->
                    <rect x="250" y="100" width="200" height="50" rx="5" fill="#2196F3" />
                    <text x="350" y="130" text-anchor="middle" fill="white">Initialize OPEN & CLOSED</text>
                    
                    <!-- Loop condition -->
                    <path d="M350,150 L350,180 L250,180 L250,210 L350,210" stroke="#333" stroke-width="2" fill="none" />
                    <polygon points="345,205 355,205 350,215" fill="#333" />
                    
                    <rect x="200" y="210" width="300" height="40" rx="20" fill="#FF9800" />
                    <text x="350" y="235" text-anchor="middle" fill="white">OPEN not empty?</text>
                    
                    <!-- Yes branch -->
                    <path d="M500,230 L550,230 L550,280 L450,280" stroke="#333" stroke-width="2" fill="none" />
                    <text x="520" y="225" font-weight="bold">YES</text>
                    <polygon points="455,275 445,275 450,285" fill="#333" />
                    
                    <!-- Get best node -->
                    <rect x="250" y="280" width="200" height="50" rx="5" fill="#9C27B0" />
                    <text x="350" y="310" text-anchor="middle" fill="white">Get node with lowest f(n)</text>
                    
                    <!-- Goal check -->
                    <path d="M350,330 L350,360" stroke="#333" stroke-width="2" fill="none" />
                    <polygon points="345,355 355,355 350,365" fill="#333" />
                    
                    <rect x="250" y="360" width="200" height="40" rx="20" fill="#FF9800" />
                    <text x="350" y="385" text-anchor="middle" fill="white">Is goal node?</text>
                    
                    <!-- Goal reached -->
                    <path d="M450,380 L500,380" stroke="#333" stroke-width="2" fill="none" />
                    <text x="470" y="375" font-weight="bold">YES</text>
                    
                    <ellipse cx="580" cy="380" rx="70" ry="25" fill="#4CAF50" />
                    <text x="580" y="385" text-anchor="middle" fill="white" font-weight="bold">SUCCESS</text>
                    
                    <!-- Continue search -->
                    <path d="M250,380 L150,380 L150,310 L250,310" stroke="#333" stroke-width="2" fill="none" />
                    <text x="120" y="375" font-weight="bold">NO</text>
                    <polygon points="255,305 245,305 250,315" fill="#333" />
                    
                    <!-- Generate neighbors -->
                    <rect x="50" y="280" width="200" height="50" rx="5" fill="#607D8B" />
                    <text x="150" y="310" text-anchor="middle" fill="white">Generate neighbors</text>
                    
                    <!-- Process neighbors -->
                    <path d="M150,280 L150,250 L200,250" stroke="#333" stroke-width="2" fill="none" />
                    <polygon points="195,245 205,245 200,255" fill="#333" />
                    
                    <rect x="200" y="230" width="200" height="40" rx="5" fill="#795548" />
                    <text x="300" y="255" text-anchor="middle" fill="white">Process neighbors</text>
                    
                    <!-- No branch -->
                    <path d="M200,230 L150,230 L150,180 L200,180" stroke="#333" stroke-width="2" fill="none" />
                    <text x="120" y="225" font-weight="bold">NO</text>
                    
                    <!-- Failure -->
                    <ellipse cx="100" cy="180" rx="70" ry="25" fill="#F44336" />
                    <text x="100" y="185" text-anchor="middle" fill="white" font-weight="bold">FAILURE</text>
                </svg>
            </div>
            
            <div style="background: #f1f1f1; padding: 20px; border-radius: 10px; margin-top: 20px;">
                <h3>Key Operations:</h3>
                <ol>
                    <li><strong>Priority Queue:</strong> OPEN list stores nodes to explore, ordered by f(n)</li>
                    <li><strong>Closed List:</strong> Tracks already evaluated nodes</li>
                    <li><strong>Neighbor Processing:</strong> Update g(n) and f(n) for each neighbor</li>
                    <li><strong>Path Reconstruction:</strong> Backtrack from goal to start when found</li>
                </ol>
            </div>
            <div class="navigation">
                <button class="nav-btn" onclick="changeSlide(3)">‚Üê Prev</button>
                <button class="nav-btn" onclick="changeSlide(5)">Next ‚Üí</button>
            </div>
        </div>

        <!-- Slide 6: Detailed Grid Example -->
        <div class="slide">
            <h2>A* in Action: Detailed Grid Example</h2>
            <div class="grid-container" id="gridExample">
                <!-- Grid will be generated by JavaScript -->
            </div>
            
            <div class="step-container">
                <div class="step-number">1</div>
                <div class="step-content">
                    <h3>Initialization</h3>
                    <p>Start at (0,0) with g=0, h=8, f=8. Add to OPEN list.</p>
                </div>
            </div>
            
            <div class="step-container">
                <div class="step-number">2</div>
                <div class="step-content">
                    <h3>First Expansion</h3>
                    <p>Expand (0,0). Neighbors: (0,1) and (1,0). Both have g=1, h=7, f=8. Add to OPEN.</p>
                </div>
            </div>
            
            <div class="step-container">
                <div class="step-number">3</div>
                <div class="step-content">
                    <h3>Continue Exploration</h3>
                    <p>Select (0,1) from OPEN. Neighbors: (0,2) with g=2, h=6, f=8. Add to OPEN.</p>
                </div>
            </div>
            
            <div class="step-container">
                <div class="step-number">4</div>
                <div class="step-content">
                    <h3>Path Discovery</h3>
                    <p>Continue until reaching (4,4) with total cost of 8. Reconstruct optimal path.</p>
                </div>
            </div>
            
            <div style="text-align: center; margin-top: 20px;">
                <button class="nav-btn" onclick="runAStarDemo()" style="background: #4CAF50;">Run A* Demo</button>
            </div>
            <div class="navigation">
                <button class="nav-btn" onclick="changeSlide(4)">‚Üê Prev</button>
                <button class="nav-btn" onclick="changeSlide(6)">Next ‚Üí</button>
            </div>
        </div>

        <!-- Slide 7: Properties -->
        <div class="slide">
            <h2>Why A* is Powerful</h2>
            <div class="visual-container">
                <svg width="700" height="300" viewBox="0 0 700 300">
                    <!-- Comparison chart -->
                    <rect x="50" y="50" width="600" height="200" fill="#f1f1f1" rx="10" />
                    
                    <!-- BFS -->
                    <g transform="translate(100, 100)">
                        <rect width="120" height="100" fill="#E1F5FE" rx="5" />
                        <text x="60" y="30" text-anchor="middle" font-weight="bold">BFS</text>
                        <text x="60" y="55" text-anchor="middle">Complete</text>
                        <text x="60" y="75" text-anchor="middle">Optimal</text>
                        <text x="60" y="95" text-anchor="middle" fill="#F44336">Slow</text>
                    </g>
                    
                    <!-- DFS -->
                    <g transform="translate(250, 100)">
                        <rect width="120" height="100" fill="#FFEBEE" rx="5" />
                        <text x="60" y="30" text-anchor="middle" font-weight="bold">DFS</text>
                        <text x="60" y="55" text-anchor="middle" fill="#F44336">Incomplete</text>
                        <text x="60" y="75" text-anchor="middle" fill="#F44336">Not optimal</text>
                        <text x="60" y="95" text-anchor="middle">Fast</text>
                    </g>
                    
                    <!-- Dijkstra -->
                    <g transform="translate(400, 100)">
                        <rect width="120" height="100" fill="#E8F5E9" rx="5" />
                        <text x="60" y="30" text-anchor="middle" font-weight="bold">Dijkstra</text>
                        <text x="60" y="55" text-anchor="middle">Complete</text>
                        <text x="60" y="75" text-anchor="middle">Optimal</text>
                        <text x="60" y="95" text-anchor="middle" fill="#F44336">Slow</text>
                    </g>
                    
                    <!-- A* -->
                    <g transform="translate(550, 100)">
                        <rect width="120" height="100" fill="#FFF8E1" rx="5" stroke="#FFC107" stroke-width="3" />
                        <text x="60" y="30" text-anchor="middle" font-weight="bold">A*</text>
                        <text x="60" y="55" text-anchor="middle" fill="#4CAF50">Complete</text>
                        <text x="60" y="75" text-anchor="middle" fill="#4CAF50">Optimal</text>
                        <text x="60" y="95" text-anchor="middle" fill="#4CAF50">Fast</text>
                    </g>
                    
                    <!-- Title -->
                    <text x="350" y="30" text-anchor="middle" font-size="20" font-weight="bold">Algorithm Comparison</text>
                </svg>
            </div>
            
            <div style="display: flex; justify-content: space-between; margin-top: 20px;">
                <div style="width: 48%;">
                    <h3>Key Properties:</h3>
                    <ul>
                        <li><strong>Completeness:</strong> Always finds solution if exists</li>
                        <li><strong>Optimality:</strong> Shortest path with admissible heuristic</li>
                        <li><strong>Efficiency:</strong> O(b^d) worst-case, but often much better</li>
                    </ul>
                </div>
                <div style="width: 48%;">
                    <h3>Performance Factors:</h3>
                    <ul>
                        <li>Heuristic quality (closer to true cost = better)</li>
                        <li>Branching factor of the graph</li>
                        <li>Depth of the solution</li>
                    </ul>
                </div>
            </div>
            <div class="navigation">
                <button class="nav-btn" onclick="changeSlide(5)">‚Üê Prev</button>
                <button class="nav-btn" onclick="changeSlide(7)">Next ‚Üí</button>
            </div>
        </div>

        <!-- Slide 8: Applications -->
        <div class="slide">
            <h2>Real-World Uses of A*</h2>
            <div class="app-grid">
                <div class="app-item">
                    <div class="app-icon">ü§ñ</div>
                    <h3>Robotics</h3>
                    <p>Path planning for autonomous robots, drones, and self-driving vehicles</p>
                </div>
                <div class="app-item">
                    <div class="app-icon">üéÆ</div>
                    <h3>Video Games</h3>
                    <p>NPC movement, strategy games, real-time pathfinding (StarCraft, Civilization)</p>
                </div>
                <div class="app-item">
                    <div class="app-icon">üåê</div>
                    <h3>Network Routing</h3>
                    <p>Shortest path in communication networks, internet routing protocols</p>
                </div>
                <div class="app-item">
                    <div class="app-icon">üß©</div>
                    <h3>AI Planning</h3>
                    <p>Solving puzzles (8-puzzle, Rubik's Cube), automated planning</p>
                </div>
                <div class="app-item">
                    <div class="app-icon">üì¶</div>
                    <h3>Logistics</h3>
                    <p>Route optimization for delivery services, warehouse management</p>
                </div>
                <div class="app-item">
                    <div class="app-icon">üó∫Ô∏è</div>
                    <h3>Mapping Services</h3>
                    <p>GPS navigation, Google Maps, finding optimal routes</p>
                </div>
            </div>
            
            <div style="text-align: center; margin-top: 30px;">
                <p style="font-size: 1.4rem; font-weight: bold; color: #1a2a6c;">A* is the gold standard for pathfinding in AI</p>
            </div>
            <div class="navigation">
                <button class="nav-btn" onclick="changeSlide(6)">‚Üê Prev</button>
                <button class="nav-btn" onclick="changeSlide(8)">Next ‚Üí</button>
            </div>
        </div>

        <!-- Slide 9: Limitations & Optimizations -->
        <div class="slide">
            <h2>Challenges and Improvements</h2>
            <div style="display: flex; justify-content: space-between; margin-top: 20px;">
                <div style="width: 48%;">
                    <h3 style="color: #F44336;">Limitations</h3>
                    <ul>
                        <li><strong>Memory Intensive:</strong> Stores all nodes in OPEN/CLOSED lists</li>
                        <li><strong>Heuristic Dependency:</strong> Performance varies with heuristic quality</li>
                        <li><strong>Dynamic Environments:</strong> Requires re-planning when changes occur</li>
                        <li><strong>Large Graphs:</strong> Can be slow for very large state spaces</li>
                    </ul>
                </div>
                <div style="width: 48%;">
                    <h3 style="color: #4CAF50;">Optimizations</h3>
                    <ul>
                        <li><strong>D* Lite:</strong> For dynamic environments with moving obstacles</li>
                        <li><strong>Hierarchical A*:</strong> Uses abstraction layers for large maps</li>
                        <li><strong>Bidirectional A*:</strong> Searches from both start and goal</li>
                        <li><strong>Jump Point Search:</strong> Optimized for uniform-cost grids</li>
                        <li><strong>Memory-Bounded A*:</strong> Limits memory usage (SMA*, IDA*)</li>
                    </ul>
                </div>
            </div>
            
            <div class="visual-container">
                <svg width="600" height="250" viewBox="0 0 600 250">
                    <!-- Hierarchical A* visualization -->
                    <rect x="50" y="50" width="500" height="150" fill="#f1f1f1" rx="10" />
                    
                    <!-- High level -->
                    <g transform="translate(100, 80)">
                        <rect width="400" height="40" fill="#E3F2FD" rx="5" />
                        <text x="200" y="25" text-anchor="middle" font-weight="bold">High-Level Abstraction</text>
                    </g>
                    
                    <!-- Mid level -->
                    <g transform="translate(150, 130)">
                        <rect width="300" height="40" fill="#E8F5E9" rx="5" />
                        <text x="150" y="25" text-anchor="middle" font-weight="bold">Mid-Level Planning</text>
                    </g>
                    
                    <!-- Low level -->
                    <g transform="translate(200, 180)">
                        <rect width="200" height="40" fill="#FFF3E0" rx="5" />
                        <text x="100" y="25" text-anchor="middle" font-weight="bold">Detailed Path</text>
                    </g>
                    
                    <!-- Arrows -->
                    <path d="M300,120 L300,130" stroke="#333" stroke-width="2" />
                    <polygon points="295,125 305,125 300,135" fill="#333" />
                    
                    <path d="M300,170 L300,180" stroke="#333" stroke-width="2" />
                    <polygon points="295,175 305,175 300,185" fill="#333" />
                    
                    <text x="300" y="40" text-anchor="middle" font-weight="bold">Hierarchical A* Approach</text>
                </svg>
            </div>
            <div class="navigation">
                <button class="nav-btn" onclick="changeSlide(7)">‚Üê Prev</button>
                <button class="nav-btn" onclick="changeSlide(9)">Next ‚Üí</button>
            </div>
        </div>

        <!-- Slide 10: Real-Time Software Example -->
        <div class="slide">
            <h2>Integrating A* in a Pathfinding Application</h2>
            
            <div class="integration-diagram">
                <div class="integration-step">
                    <h3>1. Problem Definition</h3>
                    <p>Define the environment, obstacles, start and goal positions</p>
                </div>
                <div class="integration-step">
                    <h3>2. Algorithm Implementation</h3>
                    <p>Code the A* algorithm with appropriate data structures</p>
                </div>
                <div class="integration-step">
                    <h3>3. Visualization</h3>
                    <p>Create UI to display the environment and pathfinding results</p>
                </div>
            </div>
            
            <div class="tab-container">
                <div class="tab-buttons">
                    <button class="tab-button active" onclick="openTab(event, 'python-tab')">Python</button>
                    <button class="tab-button" onclick="openTab(event, 'javascript-tab')">JavaScript</button>
                    <button class="tab-button" onclick="openTab(event, 'csharp-tab')">C#</button>
                </div>
                
                <div id="python-tab" class="tab-content active">
                    <div class="code-block">
<span class="code-comment"># A* Algorithm Implementation in Python</span>
<span class="code-keyword">import</span> heapq
<span class="code-keyword">from</span> collections <span class="code-keyword">import</span> defaultdict

<span class="code-keyword">def</span> <span class="code-function">heuristic</span>(a, b):
    <span class="code-comment"># Manhattan distance</span>
    <span class="code-keyword">return</span> <span class="code-function">abs</span>(a[<span class="code-number">0</span>] - b[<span class="code-number">0</span>]) + <span class="code-function">abs</span>(a[<span class="code-number">1</span>] - b[<span class="code-number">1</span>])

<span class="code-keyword">def</span> <span class="code-function">astar</span>(grid, start, goal):
    <span class="code-comment"># Initialize data structures</span>
    open_set = []
    heapq.<span class="code-function">push</span>(open_set, (<span class="code-number">0</span>, start))
    came_from = {}
    g_score = defaultdict(<span class="code-keyword">lambda</span>: <span class="code-function">float</span>(<span class="code-string">'inf'</span>))
    g_score[start] = <span class="code-number">0</span>
    f_score = defaultdict(<span class="code-keyword">lambda</span>: <span class="code-function">float</span>(<span class="code-string">'inf'</span>))
    f_score[start] = <span class="code-function">heuristic</span>(start, goal)
    
    <span class="code-keyword">while</span> open_set:
        current = heapq.<span class="code-function">heappop</span>(open_set)[<span class="code-number">1</span>]
        
        <span class="code-keyword">if</span> current == goal:
            <span class="code-comment"># Reconstruct path</span>
            path = []
            <span class="code-keyword">while</span> current <span class="code-keyword">in</span> came_from:
                path.<span class="code-function">append</span>(current)
                current = came_from[current]
            path.<span class="code-function">append</span>(start)
            <span class="code-keyword">return</span> path[::-<span class="code-number">1</span>]
        
        <span class="code-keyword">for</span> dx, dy <span class="code-keyword">in</span> [(<span class="code-number">0</span>,<span class="code-number">1</span>), (<span class="code-number">1</span>,<span class="code-number">0</span>), (<span class="code-number">0</span>,-<span class="code-number">1</span>), (-<span class="code-number">1</span>,<span class="code-number">0</span>)]:
            neighbor = (current[<span class="code-number">0</span>] + dx, current[<span class="code-number">1</span>] + dy)
            
            <span class="code-comment"># Check if neighbor is valid</span>
            <span class="code-keyword">if</span> (<span class="code-number">0</span> <= neighbor[<span class="code-number">0</span>] < len(grid) <span class="code-keyword">and</span> 
                <span class="code-number">0</span> <= neighbor[<span class="code-number">1</span>] < len(grid[<span class="code-number">0</span>]) <span class="code-keyword">and</span>
                grid[neighbor[<span class="code-number">0</span>]][neighbor[<span class="code-number">1</span>]] == <span class="code-number">0</span>):
                
                tentative_g_score = g_score[current] + <span class="code-number">1</span>
                
                <span class="code-keyword">if</span> tentative_g_score < g_score[neighbor]:
                    came_from[neighbor] = current
                    g_score[neighbor] = tentative_g_score
                    f_score[neighbor] = tentative_g_score + <span class="code-function">heuristic</span>(neighbor, goal)
                    heapq.<span class="code-function">push</span>(open_set, (f_score[neighbor], neighbor))
    
    <span class="code-keyword">return</span> <span class="code-keyword">None</span>  <span class="code-comment"># No path found</span>
                    </div>
                </div>
                
                <div id="javascript-tab" class="tab-content">
                    <div class="code-block">
<span class="code-comment">// A* Algorithm Implementation in JavaScript</span>
<span class="code-keyword">function</span> <span class="code-function">heuristic</span>(a, b) {
    <span class="code-comment">// Manhattan distance</span>
    <span class="code-keyword">return</span> Math.<span class="code-function">abs</span>(a.x - b.x) + Math.<span class="code-function">abs</span>(a.y - b.y);
}

<span class="code-keyword">function</span> <span class="code-function">astar</span>(grid, start, goal) {
    <span class="code-comment">// Initialize data structures</span>
    <span class="code-keyword">const</span> openSet = [];
    openSet.<span class="code-function">push</span>(start);
    
    <span class="code-keyword">const</span> cameFrom = {};
    
    <span class="code-keyword">const</span> gScore = {};
    <span class="code-keyword">for</span> (<span class="code-keyword">let</span> i = <span class="code-number">0</span>; i < grid.length; i++) {
        <span class="code-keyword">for</span> (<span class="code-keyword">let</span> j = <span class="code-number">0</span>; j < grid[<span class="code-number">0</span>].length; j++) {
            gScore[<span class="code-string">`${i},${j}`</span>] = Infinity;
        }
    }
    gScore[<span class="code-string">`${start.x},${start.y}`</span>] = <span class="code-number">0</span>;
    
    <span class="code-keyword">const</span> fScore = {};
    <span class="code-keyword">for</span> (<span class="code-keyword">let</span> i = <span class="code-number">0</span>; i < grid.length; i++) {
        <span class="code-keyword">for</span> (<span class="code-keyword">let</span> j = <span class="code-number">0</span>; j < grid[<span class="code-number">0</span>].length; j++) {
            fScore[<span class="code-string">`${i},${j}`</span>] = Infinity;
        }
    }
    fScore[<span class="code-string">`${start.x},${start.y}`</span>] = <span class="code-function">heuristic</span>(start, goal);
    
    <span class="code-keyword">while</span> (openSet.length > <span class="code-number">0</span>) {
        <span class="code-comment">// Find node with lowest fScore</span>
        <span class="code-keyword">let</span> current = openSet[<span class="code-number">0</span>];
        <span class="code-keyword">let</span> currentIndex = <span class="code-number">0</span>;
        
        <span class="code-keyword">for</span> (<span class="code-keyword">let</span> i = <span class="code-number">1</span>; i < openSet.length; i++) {
            <span class="code-keyword">const</span> node = openSet[i];
            <span class="code-keyword">if</span> (fScore[<span class="code-string">`${node.x},${node.y}`</span>] < fScore[<span class="code-string">`${current.x},${current.y}`</span>]) {
                current = node;
                currentIndex = i;
            }
        }
        
        <span class="code-comment">// Remove current from openSet</span>
        openSet.<span class="code-function">splice</span>(currentIndex, <span class="code-number">1</span>);
        
        <span class="code-keyword">if</span> (current.x === goal.x && current.y === goal.y) {
            <span class="code-comment">// Reconstruct path</span>
            <span class="code-keyword">const</span> path = [];
            <span class="code-keyword">let</span> temp = current;
            <span class="code-keyword">while</span> (temp) {
                path.<span class="code-function">push</span>(temp);
                temp = cameFrom[<span class="code-string">`${temp.x},${temp.y}`</span>];
            }
            <span class="code-keyword">return</span> path.<span class="code-function">reverse</span>();
        }
        
        <span class="code-comment">// Process neighbors</span>
        <span class="code-keyword">const</span> dirs = [{x: <span class="code-number">0</span>, y: <span class="code-number">1</span>}, {x: <span class="code-number">1</span>, y: <span class="code-number">0</span>}, {x: <span class="code-number">0</span>, y: -<span class="code-number">1</span>}, {x: -<span class="code-number">1</span>, y: <span class="code-number">0</span>}];
        
        <span class="code-keyword">for</span> (<span class="code-keyword">const</span> dir <span class="code-keyword">of</span> dirs) {
            <span class="code-keyword">const</span> neighbor = {x: current.x + dir.x, y: current.y + dir.y};
            
            <span class="code-comment">// Check if neighbor is valid</span>
            <span class="code-keyword">if</span> (neighbor.x >= <span class="code-number">0</span> && neighbor.x < grid.length &&
                neighbor.y >= <span class="code-number">0</span> && neighbor.y < grid[<span class="code-number">0</span>].length &&
                grid[neighbor.x][neighbor.y] === <span class="code-number">0</span>) {
                
                <span class="code-keyword">const</span> tentativeGScore = gScore[<span class="code-string">`${current.x},${current.y}`</span>] + <span class="code-number">1</span>;
                
                <span class="code-keyword">if</span> (tentativeGScore < gScore[<span class="code-string">`${neighbor.x},${neighbor.y}`</span>]) {
                    cameFrom[<span class="code-string">`${neighbor.x},${neighbor.y}`</span>] = current;
                    gScore[<span class="code-string">`${neighbor.x},${neighbor.y}`</span>] = tentativeGScore;
                    fScore[<span class="code-string">`${neighbor.x},${neighbor.y}`</span>] = tentativeGScore + <span class="code-function">heuristic</span>(neighbor, goal);
                    
                    <span class="code-keyword">if</span> (!openSet.<span class="code-function">some</span>(node => node.x === neighbor.x && node.y === neighbor.y)) {
                        openSet.<span class="code-function">push</span>(neighbor);
                    }
                }
            }
        }
    }
    
    <span class="code-keyword">return</span> <span class="code-keyword">null</span>;  <span class="code-comment">// No path found</span>
}
                    </div>
                </div>
                
                <div id="csharp-tab" class="tab-content">
                    <div class="code-block">
<span class="code-comment">// A* Algorithm Implementation in C#</span>
<span class="code-keyword">using</span> System;
<span class="code-keyword">using</span> System.Collections.Generic;

<span class="code-keyword">public class</span> <span class="code-function">Point</span>
{
    <span class="code-keyword">public int</span> X { <span class="code-keyword">get</span>; <span class="code-keyword">set</span>; }
    <span class="code-keyword">public int</span> Y { <span class="code-keyword">get</span>; <span class="code-keyword">set</span>; }
    
    <span class="code-keyword">public</span> <span class="code-function">Point</span>(<span class="code-keyword">int</span> x, <span class="code-keyword">int</span> y)
    {
        X = x;
        Y = y;
    }
}

<span class="code-keyword">public class</span> <span class="code-function">AStar</span>
{
    <span class="code-keyword">public static</span> <span class="code-keyword">int</span> <span class="code-function">Heuristic</span>(Point a, Point b)
    {
        <span class="code-comment">// Manhattan distance</span>
        <span class="code-keyword">return</span> Math.Abs(a.X - b.X) + Math.Abs(a.Y - b.Y);
    }
    
    <span class="code-keyword">public static</span> List<Point> <span class="code-function">FindPath</span>(<span class="code-keyword">int</span>[,] grid, Point start, Point goal)
    {
        <span class="code-comment">// Initialize data structures</span>
        <span class="code-keyword">var</span> openSet = <span class="code-keyword">new</span> List<Point> { start };
        <span class="code-keyword">var</span> cameFrom = <span class="code-keyword">new</span> Dictionary<Point, Point>();
        
        <span class="code-keyword">var</span> gScore = <span class="code-keyword">new</span> Dictionary<Point, <span class="code-keyword">int</span>>();
        <span class="code-keyword">for</span> (<span class="code-keyword">int</span> x = <span class="code-number">0</span>; x < grid.GetLength(<span class="code-number">0</span>); x++)
        {
            <span class="code-keyword">for</span> (<span class="code-keyword">int</span> y = <span class="code-number">0</span>; y < grid.GetLength(<span class="code-number">1</span>); y++)
            {
                gScore[<span class="code-keyword">new</span> Point(x, y)] = <span class="code-keyword">int</span>.MaxValue;
            }
        }
        gScore[start] = <span class="code-number">0</span>;
        
        <span class="code-keyword">var</span> fScore = <span class="code-keyword">new</span> Dictionary<Point, <span class="code-keyword">int</span>>();
        <span class="code-keyword">for</span> (<span class="code-keyword">int</span> x = <span class="code-number">0</span>; x < grid.GetLength(<span class="code-number">0</span>); x++)
        {
            <span class="code-keyword">for</span> (<span class="code-keyword">int</span> y = <span class="code-number">0</span>; y < grid.GetLength(<span class="code-number">1</span>); y++)
            {
                fScore[<span class="code-keyword">new</span> Point(x, y)] = <span class="code-keyword">int</span>.MaxValue;
            }
        }
        fScore[start] = <span class="code-function">Heuristic</span>(start, goal);
        
        <span class="code-keyword">while</span> (openSet.Count > <span class="code-number">0</span>)
        {
            <span class="code-comment">// Find node with lowest fScore</span>
            Point current = openSet[<span class="code-number">0</span>];
            <span class="code-keyword">int</span> currentIndex = <span class="code-number">0</span>;
            
            <span class="code-keyword">for</span> (<span class="code-keyword">int</span> i = <span class="code-number">1</span>; i < openSet.Count; i++)
            {
                <span class="code-keyword">if</span> (fScore[openSet[i]] < fScore[current])
                {
                    current = openSet[i];
                    currentIndex = i;
                }
            }
            
            <span class="code-comment">// Remove current from openSet</span>
            openSet.RemoveAt(currentIndex);
            
            <span class="code-keyword">if</span> (current.X == goal.X && current.Y == goal.Y)
            {
                <span class="code-comment">// Reconstruct path</span>
                <span class="code-keyword">var</span> path = <span class="code-keyword">new</span> List<Point>();
                <span class="code-keyword">var</span> temp = current;
                
                <span class="code-keyword">while</span> (cameFrom.ContainsKey(temp))
                {
                    path.Add(temp);
                    temp = cameFrom[temp];
                }
                
                path.Add(start);
                path.Reverse();
                <span class="code-keyword">return</span> path;
            }
            
            <span class="code-comment">// Process neighbors</span>
            <span class="code-keyword">var</span> directions = <span class="code-keyword">new</span> List<Point> {
                <span class="code-keyword">new</span> Point(<span class="code-number">0</span>, <span class="code-number">1</span>),
                <span class="code-keyword">new</span> Point(<span class="code-number">1</span>, <span class="code-number">0</span>),
                <span class="code-keyword">new</span> Point(<span class="code-number">0</span>, -<span class="code-number">1</span>),
                <span class="code-keyword">new</span> Point(-<span class="code-number">1</span>, <span class="code-number">0</span>)
            };
            
            <span class="code-keyword">foreach</span> (<span class="code-keyword">var</span> dir <span class="code-keyword">in</span> directions)
            {
                <span class="code-keyword">var</span> neighbor = <span class="code-keyword">new</span> Point(current.X + dir.X, current.Y + dir.Y);
                
                <span class="code-comment">// Check if neighbor is valid</span>
                <span class="code-keyword">if</span> (neighbor.X >= <span class="code-number">0</span> && neighbor.X < grid.GetLength(<span class="code-number">0</span>) &&
                    neighbor.Y >= <span class="code-number">0</span> && neighbor.Y < grid.GetLength(<span class="code-number">1</span>) &&
                    grid[neighbor.X, neighbor.Y] == <span class="code-number">0</span>)
                {
                    <span class="code-keyword">int</span> tentativeGScore = gScore[current] + <span class="code-number">1</span>;
                    
                    <span class="code-keyword">if</span> (tentativeGScore < gScore[neighbor])
                    {
                        cameFrom[neighbor] = current;
                        gScore[neighbor] = tentativeGScore;
                        fScore[neighbor] = tentativeGScore + <span class="code-function">Heuristic</span>(neighbor, goal);
                        
                        <span class="code-keyword">if</span> (!openSet.Contains(neighbor))
                        {
                            openSet.Add(neighbor);
                        }
                    }
                }
            }
        }
        
        <span class="code-keyword">return null</span>;  <span class="code-comment">// No path found</span>
    }
}
                    </div>
                </div>
            </div>
            
            <div class="navigation">
                <button class="nav-btn" onclick="changeSlide(8)">‚Üê Prev</button>
                <button class="nav-btn" onclick="changeSlide(10)">Next ‚Üí</button>
            </div>
        </div>

        <!-- Slide 11: Code Implementation -->
        <div class="slide">
            <h2>Complete Implementation Example</h2>
            
            <div class="tab-container">
                <div class="tab-buttons">
                    <button class="tab-button active" onclick="openTab(event, 'integration-tab')">Integration</button>
                    <button class="tab-button" onclick="openTab(event, 'visualization-tab')">Visualization</button>
                    <button class="tab-button" onclick="openTab(event, 'optimization-tab')">Optimization</button>
                </div>
                
                <div id="integration-tab" class="tab-content active">
                    <h3>Integrating A* in a Real-Time Application</h3>
                    <div class="code-block">
<span class="code-comment">// Example: Integrating A* in a game engine (Unity)</span>
<span class="code-keyword">using</span> UnityEngine;
<span class="code-keyword">using</span> System.Collections.Generic;

<span class="code-keyword">public class</span> <span class="code-function">PathfindingAgent</span> : MonoBehaviour
{
    <span class="code-keyword">public</span> Grid grid;
    <span class="code-keyword">public</span> Transform target;
    <span class="code-keyword">public float</span> speed = <span class="code-number">5f</span>;
    
    <span class="code-keyword">private</span> List<Node> path;
    <span class="code-keyword">private int</span> targetIndex;
    
    <span class="code-keyword">void</span> <span class="code-function">Update</span>()
    {
        <span class="code-comment">// Update path periodically or when target moves significantly</span>
        <span class="code-keyword">if</span> (Input.GetButtonDown(<span class="code-string">"Jump"</span>))
        {
            <span class="code-function">FindPath</span>(transform.position, target.position);
        }
        
        <span class="code-comment">// Move along the path</span>
        <span class="code-keyword">if</span> (path != <span class="code-keyword">null</span>)
        {
            <span class="code-function">FollowPath</span>();
        }
    }
    
    <span class="code-keyword">void</span> <span class="code-function">FindPath</span>(Vector3 startPos, Vector3 targetPos)
    {
        Node startNode = grid.<span class="code-function">NodeFromWorldPoint</span>(startPos);
        Node targetNode = grid.<span class="code-function">NodeFromWorldPoint</span>(targetPos);
        
        <span class="comment">// Use A* to find path</span>
        path = <span class="code-function">AStar</span>.<span class="code-function">FindPath</span>(grid, startNode, targetNode);
        targetIndex = <span class="code-number">0</span>;
    }
    
    <span class="code-keyword">void</span> <span class="code-function">FollowPath</span>()
    {
        <span class="code-keyword">if</span> (targetIndex >= path.Count)
        {
            <span class="code-comment">// Reached destination</span>
            path = <span class="code-keyword">null</span>;
            <span class="code-keyword">return</span>;
        }
        
        Vector3 currentWaypoint = path[targetIndex].worldPosition;
        transform.position = Vector3.<span class="code-function">MoveTowards</span>(
            transform.position, 
            currentWaypoint, 
            speed * Time.deltaTime
        );
        
        <span class="code-keyword">if</span> (transform.position == currentWaypoint)
        {
            targetIndex++;
        }
    }
}
                    </div>
                </div>
                
                <div id="visualization-tab" class="tab-content">
                    <h3>Visualizing A* in Real-Time</h3>
                    <div class="code-block">
<span class="code-comment">// Example: Visualizing A* search process</span>
<span class="code-keyword">function</span> <span class="code-function">visualizeAStar</span>(grid, start, goal) {
    <span class="code-comment">// Clear previous visualization</span>
    clearVisualization();
    
    <span class="code-comment">// Track visited nodes for visualization</span>
    <span class="code-keyword">const</span> visitedNodes = [];
    
    <span class="code-comment">// Modified A* algorithm with visualization callbacks</span>
    <span class="code-keyword">function</span> <span class="code-function">astarWithVisualization</span>() {
        <span class="code-comment">// ... A* implementation ...</span>
        
        <span class="code-comment">// When visiting a node, add to visualization queue</span>
        visitedNodes.<span class="code-function">push</span>({
            node: current,
            type: <span class="code-string">'current'</span>
        });
        
        <span class="code-comment">// When processing neighbors, add to visualization queue</span>
        <span class="code-keyword">for</span> (<span class="code-keyword">const</span> neighbor <span class="code-keyword">of</span> neighbors) {
            visitedNodes.<span class="code-function">push</span>({
                node: neighbor,
                type: <span class="code-string">'visited'</span>
            });
        }
        
        <span class="code-comment">// When path is found, add to visualization queue</span>
        <span class="code-keyword">if</span> (path) {
            <span class="code-keyword">for</span> (<span class="code-keyword">const</span> node <span class="code-keyword">of</span> path) {
                visitedNodes.<span class="code-function">push</span>({
                    node: node,
                    type: <span class="code-string">'path'</span>
                });
            }
        }
    }
    
    <span class="code-comment">// Run the algorithm</span>
    <span class="code-function">astarWithVisualization</span>();
    
    <span class="code-comment">// Animate the visualization</span>
    <span class="code-keyword">let</span> i = <span class="code-number">0</span>;
    <span class="code-keyword">const</span> interval = setInterval(() => {
        <span class="code-keyword">if</span> (i >= visitedNodes.length) {
            clearInterval(interval);
            <span class="code-keyword">return</span>;
        }
        
        <span class="code-keyword">const</span> { node, type } = visitedNodes[i];
        <span class="code-function">visualizeNode</span>(node, type);
        i++;
    }, <span class="code-number">50</span>);  <span class="code-comment">// 50ms delay between steps</span>
}

<span class="code-keyword">function</span> <span class="code-function">visualizeNode</span>(node, type) {
    <span class="code-keyword">const</span> cellElement = document.<span class="code-function">getElementById</span>(<span class="code-string">`cell-${node.x}-${node.y}`</span>);
    
    <span class="code-keyword">switch</span> (type) {
        <span class="code-keyword">case</span> <span class="code-string">'current'</span>:
            cellElement.classList.add(<span class="code-string">'current'</span>);
            setTimeout(() => {
                cellElement.classList.remove(<span class="code-string">'current'</span>);
                cellElement.classList.add(<span class="code-string">'visited'</span>);
            }, <span class="code-number">100</span>);
            <span class="code-keyword">break</span>;
        <span class="code-keyword">case</span> <span class="code-string">'visited'</span>:
            cellElement.classList.add(<span class="code-string">'visited'</span>);
            <span class="code-keyword">break</span>;
        <span class="code-keyword">case</span> <span class="code-string">'path'</span>:
            cellElement.classList.add(<span class="code-string">'path'</span>);
            <span class="code-keyword">break</span>;
    }
}
                    </div>
                </div>
                
                <div id="optimization-tab" class="tab-content">
                    <h3>Optimizing A* for Real-Time Applications</h3>
                    <div class="code-block">
<span class="code-comment">// Example: Optimizing A* with a priority queue</span>
<span class="code-keyword">import</span> heapq
<span class="code-keyword">from</span> collections <span class="code-keyword">import</span> defaultdict

<span class="code-keyword">class</span> <span class="code-function">PriorityQueue</span>:
    <span class="code-keyword">def</span> <span class="code-function">__init__</span>(self):
        self.elements = []
    
    <span class="code-keyword">def</span> <span class="code-function">empty</span>(self):
        <span class="code-keyword">return</span> <span class="code-keyword">not</span> self.elements
    
    <span class="code-keyword">def</span> <span class="code-function">put</span>(self, item, priority):
        heapq.<span class="code-function">heappush</span>(self.elements, (priority, item))
    
    <span class="code-keyword">def</span> <span class="code-function">get</span>(self):
        <span class="code-keyword">return</span> heapq.<span class="code-function">heappop</span>(self.elements)[<span class="code-number">1</span>]

<span class="code-keyword">def</span> <span class="code-function">optimized_astar</span>(grid, start, goal):
    <span class="code-comment"># Use priority queue for efficient node retrieval</span>
    open_set = <span class="code-function">PriorityQueue</span>()
    open_set.<span class="code-function">put</span>(start, <span class="code-number">0</span>)
    
    came_from = {}
    g_score = defaultdict(<span class="code-keyword">lambda</span>: <span class="code-function">float</span>(<span class="code-string">'inf'</span>))
    g_score[start] = <span class="code-number">0</span>
    f_score = defaultdict(<span class="code-keyword">lambda</span>: <span class="code-function">float</span>(<span class="code-string">'inf'</span>))
    f_score[start] = <span class="code-function">heuristic</span>(start, goal)
    
    <span class="code-comment"># Use a set for O(1) membership tests</span>
    open_set_hash = {start}
    
    <span class="code-keyword">while</span> <span class="code-keyword">not</span> open_set.<span class="code-function">empty</span>():
        current = open_set.<span class="code-function">get</span>()
        open_set_hash.<span class="code-function">remove</span>(current)
        
        <span class="code-keyword">if</span> current == goal:
            <span class="code-keyword">return</span> <span class="code-function">reconstruct_path</span>(came_from, current)
        
        <span class="code-keyword">for</span> neighbor <span class="code-keyword">in</span> <span class="code-function">get_neighbors</span>(grid, current):
            tentative_g_score = g_score[current] + <span class="code-number">1</span>
            
            <span class="code-keyword">if</span> tentative_g_score < g_score[neighbor]:
                came_from[neighbor] = current
                g_score[neighbor] = tentative_g_score
                f_score[neighbor] = tentative_g_score + <span class="code-function">heuristic</span>(neighbor, goal)
                
                <span class="code-keyword">if</span> neighbor <span class="code-keyword">not in</span> open_set_hash:
                    open_set.<span class="code-function">put</span>(neighbor, f_score[neighbor])
                    open_set_hash.<span class="code-function">add</span>(neighbor)
    
    <span class="code-keyword">return</span> <span class="code-keyword">None</span>  <span class="code-comment"># No path found</span>
                    </div>
                </div>
            </div>
            
            <div class="navigation">
                <button class="nav-btn" onclick="changeSlide(9)">‚Üê Prev</button>
                <button class="nav-btn" onclick="changeSlide(11)">Next ‚Üí</button>
            </div>
        </div>

        <!-- Slide 12: Conclusion -->
        <div class="slide">
            <h2>Summary</h2>
            <div class="visual-container">
                <svg width="500" height="300" viewBox="0 0 500 300">
                    <!-- Central circle -->
                    <circle cx="250" cy="150" r="80" fill="#1a2a6c" />
                    <text x="250" y="150" text-anchor="middle" fill="white" font-size="24" font-weight="bold">A*</text>
                    
                    <!-- Surrounding concepts -->
                    <g transform="translate(100, 50)">
                        <circle cx="0" cy="0" r="40" fill="#4CAF50" />
                        <text x="0" y="5" text-anchor="middle" fill="white" font-weight="bold">Optimal</text>
                    </g>
                    
                    <g transform="translate(400, 50)">
                        <circle cx="0" cy="0" r="40" fill="#2196F3" />
                        <text x="0" y="5" text-anchor="middle" fill="white" font-weight="bold">Efficient</text>
                    </g>
                    
                    <g transform="translate(100, 250)">
                        <circle cx="0" cy="0" r="40" fill="#FF9800" />
                        <text x="0" y="5" text-anchor="middle" fill="white" font-weight="bold">Heuristic</text>
                    </g>
                    
                    <g transform="translate(400, 250)">
                        <circle cx="0" cy="0" r="40" fill="#9C27B0" />
                        <text x="0" y="5" text-anchor="middle" fill="white" font-weight="bold">Complete</text>
                    </g>
                    
                    <!-- Connecting lines -->
                    <line x1="140" y1="80" x2="180" y2="110" stroke="#333" stroke-width="2" />
                    <line x1="360" y1="80" x2="320" y2="110" stroke="#333" stroke-width="2" />
                    <line x1="140" y1="220" x2="180" y2="190" stroke="#333" stroke-width="2" />
                    <line x1="360" y1="220" x2="320" y2="190" stroke="#333" stroke-width="2" />
                </svg>
            </div>
            
            <div style="text-align: center; margin-top: 30px;">
                <p style="font-size: 1.4rem; margin-bottom: 15px;">A* is the <span class="highlight">gold standard</span> for pathfinding in AI</p>
                <p style="font-size: 1.2rem;">Combines optimality and efficiency using f(n) = g(n) + h(n)</p>
                <p style="font-size: 1.2rem; margin-top: 15px;">Success hinges on an <span class="highlight">admissible heuristic</span></p>
                <p style="font-size: 1.4rem; margin-top: 20px; font-weight: bold; color: #1a2a6c;">A* bridges theory and real-world problem-solving</p>
            </div>
            <div class="navigation">
                <button class="nav-btn" onclick="changeSlide(10)">‚Üê Prev</button>
                <button class="nav-btn" onclick="changeSlide(12)">Next ‚Üí</button>
            </div>
        </div>

        <!-- Slide 13: References -->
        <div class="slide">
            <h2>Learn More</h2>
            <div style="background: #f1f1f1; padding: 20px; border-radius: 10px; margin-bottom: 20px;">
                <h3>Books</h3>
                <ul>
                    <li>Russell, S., & Norvig, P. (2020). <em>Artificial Intelligence: A Modern Approach</em>. 4th Edition.</li>
                    <li>Hart, P. E., Nilsson, N. J., & Raphael, B. (1968). "A Formal Basis for the Heuristic Determination of Minimum Cost Paths".</li>
                </ul>
            </div>
            
            <div style="background: #f1f1f1; padding: 20px; border-radius: 10px;">
                <h3>Online Resources</h3>
                <ul>
                    <li><a href="https://www.redblobgames.com/pathfinding/a-star/introduction.html" target="_blank" style="color: #1a2a6c;">Red Blob Games: A* Introduction</a> - Interactive visualizations</li>
                    <li><a href="https://stanford.edu/~cpiech/cs221/apps/aStar.html" target="_blank" style="color: #1a2a6c;">Stanford CS221: A* Notes</a> - Academic explanations</li>
                    <li><a href="https://qiao.github.io/PathFinding.js/visual/" target="_blank" style="color: #1a2a6c;">Pathfinding.js</a> - Interactive demos</li>
                    <li><a href="https://en.wikipedia.org/wiki/A*_search_algorithm" target="_blank" style="color: #1a2a6c;">Wikipedia: A* search algorithm</a> - Comprehensive overview</li>
                </ul>
            </div>
            
            <div style="text-align: center; margin-top: 30px;">
                <p style="font-size: 1.4rem; font-weight: bold; color: #1a2a6c;">Thank You!</p>
            </div>
            <div class="navigation">
                <button class="nav-btn" onclick="changeSlide(11)">‚Üê Prev</button>
            </div>
        </div>
    </div>

    <script>
        let currentSlide = 0;
        const slides = document.querySelectorAll('.slide');
        
        function changeSlide(n) {
            slides[currentSlide].classList.remove('active');
            currentSlide = (n + slides.length) % slides.length;
            slides[currentSlide].classList.add('active');
        }
        
        function openTab(evt, tabName) {
            // Hide all tab content
            const tabContents = document.getElementsByClassName('tab-content');
            for (let i = 0; i < tabContents.length; i++) {
                tabContents[i].classList.remove('active');
            }
            
            // Remove active class from all tab buttons
            const tabButtons = document.getElementsByClassName('tab-button');
            for (let i = 0; i < tabButtons.length; i++) {
                tabButtons[i].classList.remove('active');
            }
            
            // Show the specific tab content
            document.getElementById(tabName).classList.add('active');
            
            // Add active class to the button that opened the tab
            evt.currentTarget.classList.add('active');
        }
        
        // Initialize grid for slide 6
        function initGrid() {
            const gridContainer = document.getElementById('gridExample');
            const gridSize = 5;
            let gridHTML = '<div style="display: grid; grid-template-columns: repeat(5, 1fr); gap: 5px;">';
            
            for (let y = 0; y < gridSize; y++) {
                for (let x = 0; x < gridSize; x++) {
                    let cellClass = 'grid-cell';
                    let cellContent = '';
                    
                    if (x === 0 && y === 0) {
                        cellClass += ' start';
                        cellContent = 'S';
                    } else if (x === 4 && y === 4) {
                        cellClass += ' goal';
                        cellContent = 'G';
                    } else if ((x === 1 && y === 1) || (x === 2 && y === 2) || (x === 3 && y === 3)) {
                        cellClass += ' obstacle';
                        cellContent = 'X';
                    }
                    
                    gridHTML += `<div class="${cellClass}" id="cell-${x}-${y}">${cellContent}</div>`;
                }
            }
            
            gridHTML += '</div>';
            gridContainer.innerHTML = gridHTML;
        }
        
        // A* demo for slide 6
        function runAStarDemo() {
            initGrid();
            
            // Simple A* implementation for demo
            const gridSize = 5;
            const start = {x: 0, y: 0};
            const goal = {x: 4, y: 4};
            const obstacles = [{x: 1, y: 1}, {x: 2, y: 2}, {x: 3, y: 3}];
            
            // Heuristic function (Manhattan distance)
            function heuristic(a, b) {
                return Math.abs(a.x - b.x) + Math.abs(a.y - b.y);
            }
            
            // Get neighbors
            function getNeighbors(node) {
                const neighbors = [];
                const dirs = [{x: 0, y: 1}, {x: 1, y: 0}, {x: 0, y: -1}, {x: -1, y: 0}];
                
                for (const dir of dirs) {
                    const newX = node.x + dir.x;
                    const newY = node.y + dir.y;
                    
                    if (newX >= 0 && newX < gridSize && newY >= 0 && newY < gridSize) {
                        if (!obstacles.some(obs => obs.x === newX && obs.y === newY)) {
                            neighbors.push({x: newX, y: newY});
                        }
                    }
                }
                
                return neighbors;
            }
            
            // A* algorithm
            const openSet = [start];
            const cameFrom = {};
            const gScore = {};
            const fScore = {};
            
            gScore[`${start.x},${start.y}`] = 0;
            fScore[`${start.x},${start.y}`] = heuristic(start, goal);
            
            while (openSet.length > 0) {
                // Find node with lowest fScore
                let current = openSet[0];
                let currentIndex = 0;
                
                for (let i = 1; i < openSet.length; i++) {
                    const node = openSet[i];
                    if (fScore[`${node.x},${node.y}`] < fScore[`${current.x},${current.y}`]) {
                        current = node;
                        currentIndex = i;
                    }
                }
                
                // Remove current from openSet
                openSet.splice(currentIndex, 1);
                
                // Mark current as visited
                if (!(current.x === start.x && current.y === start.y) && 
                    !(current.x === goal.x && current.y === goal.y)) {
                    document.getElementById(`cell-${current.x}-${current.y}`).classList.add('visited');
                }
                
                // Check if we reached the goal
                if (current.x === goal.x && current.y === goal.y) {
                    // Reconstruct path
                    const path = [];
                    let temp = current;
                    
                    while (temp) {
                        path.push(temp);
                        temp = cameFrom[`${temp.x},${temp.y}`];
                    }
                    
                    // Animate path
                    path.reverse().forEach((node, index) => {
                        setTimeout(() => {
                            if (!(node.x === start.x && node.y === start.y) && 
                                !(node.x === goal.x && node.y === goal.y)) {
                                document.getElementById(`cell-${node.x}-${node.y}`).classList.add('path');
                            }
                        }, index * 200);
                    });
                    
                    return;
                }
                
                // Process neighbors
                const neighbors = getNeighbors(current);
                
                for (const neighbor of neighbors) {
                    const tentativeGScore = gScore[`${current.x},${current.y}`] + 1;
                    const neighborKey = `${neighbor.x},${neighbor.y}`;
                    
                    if (gScore[neighborKey] === undefined || tentativeGScore < gScore[neighborKey]) {
                        cameFrom[neighborKey] = current;
                        gScore[neighborKey] = tentativeGScore;
                        fScore[neighborKey] = tentativeGScore + heuristic(neighbor, goal);
                        
                        if (!openSet.some(node => node.x === neighbor.x && node.y === neighbor.y)) {
                            openSet.push(neighbor);
                        }
                    }
                }
                
                // Highlight current node
                if (!(current.x === start.x && current.y === start.y)) {
                    document.getElementById(`cell-${current.x}-${current.y}`).classList.add('current');
                    setTimeout(() => {
                        document.getElementById(`cell-${current.x}-${current.y}`).classList.remove('current');
                    }, 300);
                }
            }
        }
        
        // Initialize grid when page loads
        window.onload = function() {
            initGrid();
        };
    </script>
</body>
</html>